#include "app.h"
#include "kernel_ken.h"

// This is a basic Producer-Consumer implementation with 5 Producer process, 1 Consumer process, and a blocking 
// semaphore to indicate when an item is available in the pipe to read. There are a lot of assertions added to
// test that things work correctly, because the console is too small to display the test results. If this test 
// fails, it will trigger an ASSERTION-FAILED message. If it passes, it will simply print out something 
// like this (order of the two statements might vary - what's important is that two processes exit):
// Process #3 is exiting
// Process #2 is exiting

#define PIPE_BUFFER_SIZE 12
#define PC2_NUM_ITER 50000

unsigned int rand(unsigned int *seed)
{
    return (*seed = *seed * 214013L + 2531011L);
}

#define assert(b) ((b) ? (void)0 : u_assert(__FILE__, __LINE__, #b))
void u_assert(const char *file, unsigned int line, const char *desc) 
{
    // An assertion failed, kill the user process, I suppose.
    print("USER ASSERTION FAILED ("); 
    print(desc);
    print(") at "); 
    print(file);
    print(": ");
    print_dec(line);
    print("\n");
    for(;;);
}

void try_add_num(int pipe, void *buff, unsigned int len, unsigned int num_fails)
{
    // Linear backoff
    int ret = write(pipe, buff, len);
    if(ret == 0){
        sleep(1 * (num_fails + 1));
        try_add_num(pipe, buff, len, num_fails + 1);
    }
}

void my_app()
{
    const int BUFFER_SIZE = 8;
    const int PRODUCER_COUNT = 5;

    print("Starting test \n");

    int pipe = open_pipe();
    int sem = open_sem(0);
    int ret = fork();

    // This writes a sequence of random numbers to the pipe.
    // Because this uses a Pseudo-RNG, the Consumer can recreate the sequence of numbers generated by the Producer thread, to
    // check that the values are correct.
    if(ret == 0){
        // Processes are seeded with their PIDs, which makes recreating their sequence of random
        // numbers easy. Note that not all elements of this array are used.
        unsigned int seed_len = (PRODUCER_COUNT + 10 + (unsigned int)getpid());
        unsigned int *seeds = alloc(sizeof(unsigned int) * seed_len, 0);
        int i;
        for(i = 0; i < seed_len; i++){
            seeds[i] = (unsigned int)i;
        }

        // This reads values and checks return codes at the same time.
        // Note the use of blocking semaphores to make sure that there is always an item in the pipe
        i = 0;
        while(i < PRODUCER_COUNT * PC2_NUM_ITER){
            assert(wait(sem) == sem);

            char buff[BUFFER_SIZE];
            assert(read(pipe, buff, BUFFER_SIZE) == BUFFER_SIZE);

            // buff[0] is the process that wrote this element to the pipe
            // buff[1] is the random number that process just generated.
            unsigned int *buffer_cast = (unsigned int *)buff;
            int pid = (int)buffer_cast[0];
            unsigned int rng = buffer_cast[1];

            // Next is the value that should've been written to the pipe.
            unsigned int next = rand(seeds + pid);
            // If there's a mismatch, that's an error - something went wrong when writing/reading from the pipe
            assert(next == rng);
            i++;
        }
    } else {
        // Create (N - 1) producers (we already have one)
        int i;
        for(i = 0; i < (PRODUCER_COUNT - 1); i++){
            if(fork() == 0)
                break;
        }
        // Each producer seeds its RNG with its own PID to make this easier to automatically test with assertions
        unsigned int seed = (unsigned int)getpid();
        i = 0;
        while(i < PC2_NUM_ITER) {
            // Generate a random number
            unsigned int next = rand(&seed);

            // buff[0] is this producers PID
            // buff[1] is the random value
            char buff[BUFFER_SIZE];
            unsigned int *buffer_cast = (unsigned int *)buff;
            buffer_cast[0] = (unsigned int)getpid();
            buffer_cast[1] = next;

            // If the number cannot be written, sleep for a bit, so we don't waste a lot of CPU time
            try_add_num(pipe, buff, BUFFER_SIZE, 0);

            assert(signal(sem) == sem);
            i++;
        }
    }

    print("Process #"); print_dec(getpid()); print(" is exiting\n");

}

